Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: “Програмна система для аналізу та контролю відвідувачів басейну «Lieb ist Pool»”


Студент гр. ПЗПІ-21-10	_______________ Готвянський К. П.
							(підпис)
Керівник роботи	_______________ доц. Лещинська І. О.
							(підпис)

	Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія: 	_______________ доц. Лещинський В.О.
							(підпис)													_______________ доц. Лещинська І.О.
							(підпис)
	_______________ ст. викл. Сокорчук І.П.
							(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук		 Кафедра  програмної інженерії		
Спеціальність  121 – Інженерія програмного забезпечення					
Курс 		3             Семестр 					6					
Навчальна дисципліна  Архітектура програмного забезпечення				

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
 
Готвянському Кирилу Павловичу

1. Тема роботи: Програмна система для моніторингу та аналізу відвідувачів басейну «Lieb ist Pool»
2. Термін узгодження завдання курсової роботи: «4» березня 2024 р.
3. Термін здачі студентом закінченої роботи: «10» червня 2024 р.
4. Вихідні дані до проєкту (роботи): програмна система, що включає в себе серверну частину (Back-end), клієнтську частину (Front-end),  IoT або Smart Device програмний застосунок, вбудовані засоби адміністрування системи (управління користувачами системи, управління  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних, 
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ,
аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень):
схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки	 
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітки
1	Функціональна специфікація програмного проєкту	31.03.24	ВИКОНАНО
2	Проєктування програмного проєкту	30.04.24	ВИКОНАНО
3	Кодування програмного проєкту	20.05.24	ВИКОНАНО
4	Оформлення пояснювальної записки	31.05.24	ВИКОНАНО
5	Захист курсової роботи	08.06.24	ВИКОНАНО

	Дата видачі завдання: «4» березня 2024 р.

	Керівник				          _______________ доц. Лещинська І. О.
						                  (підпис)


	Завдання прийняв до виконання 
	ст. гр. ПЗПІ-21-10			____________  Готвянський К. П.
							       (підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 61 с., 24 рис., 2 табл., 3 додатки, 5 джерел. 
АДМІНІСТРАТОР, КЛІЄНТ, РЕКОМНДАЦІЇ, СПОРТ, БАСЕЙН,  ПРОГРАМНА СИСТЕМА

Об’єктом дослідження є індустрія рекомендацій для спортсменів, а саме актуальне на сьогоднішній день питання щодо отримання актуальних, точних та швидких рекомендацій для людей, які займаються спортом та бажають покращувати своє тіло.
Метою курсової роботи є розробка програмної системи, яка дозволяє аналізувати відвідувачів басейну, а також надавати рекомендації на основі вимірів тіла. Система забезпечує збір і обробку даних про фізичні параметри користувачів, таких як вага, зріст, вік, стать, процент жиру та м’язів, індекс маси тіла, рівень стресу і використовує ці дані для генерації персоналізованих рекомендацій щодо фізичних вправ та способу життя.
Методи розробки базуються на технології ASP.NET Core з використанням мови програмування C#, серверу бази даних PostgreSQL, веб-застосунок базується на технології React з мовою програмування TypeScript, смарт-пристрій розроблено, емулюючи поведінку реального пристрою, використовуючи ASP.NET Native AOT та консольний застосунок.
У результаті роботи здійснено програмну реалізацію системи для аналізу та моніторингу відвідувачів басейну. Програмна система складається з вебзастосунку, сервера та смартпристрою.  
ЗМІСТ


Вступ	7
1 Аналіз предметної області	8
    1.1 Бізнес-вимоги	8
        1.1.1 Бізнес-можливості	8
        1.1.2 Бізнес-цілі та критерії успіху	8
        1.1.3 Потреби клієнтів або ринку	9
        1.1.4 Бізнес-ризики	9
    1.2 Концепція рішення	10
        1.2.1 Окреслення концепції	10
        1.2.2 Головна функціональність	10
        1.2.3 Припущення та залежності	11
    1.3 Рамки та обмеження проєкту	13
        1.3.1 Рамки первинного випуску	13
        1.3.2 Рамки наступних випусків	13
        1.3.3 Обмеження та винятки	13
    1.4 Бізнес-контекст	14
        1.4.1 Профілі зацікавлених сторін	14
        1.4.2 Пріоритети проєкту	15
        1.4.3 Робоче середовище	15
2 Постановка задачі	17
3 Проєктування бази даних	18
    3.1 Побудова ER-діаграми	18
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	19
4 Архітектура програмної системи	22
    4.1 Архітектура серверної частини	22
    4.2 Архітектура IoT частини	26
    4.3 Архітектура клієнтської частини	30
5 Опис програмної системи	35
    5.1 Виклик і завантаження	35
    5.2 Призначення і логічна структура	36
    5.3 Опис програмної реалізації	37
Висновки	43
Перелік джерел посилання	44
Додаток А Програмний код серверної частини	45
Додаток Б Програмний код IoT пристрою	51
Додаток В Програмний код клієнтської частини	54
 
ВСТУП


Одним із найважливіших аспектів сучасного здорового способу життя є регулярна фізична активність. Відвідування басейну є одним з популярних способів підтримки фізичної форми та загального оздоровлення. Однак, для досягнення максимального ефекту від тренувань у басейні, необхідно мати персоналізований підхід, що враховує індивідуальні фізичні особливості та потреби кожного відвідувача. 
На сьогоднішній день басейни та спортивні комплекси стикаються з численними викликами. Недостатній контроль за фізичними параметрами відвідувачів може призвести до неефективності тренувань та збільшення ризиків травм. Крім того, відсутність систематичного підходу до моніторингу прогресу користувачів ускладнює коригування тренувальних програм та досягнення бажаних результатів. 
Зростаючий попит на індивідуальні програми тренувань та рекомендації щодо фізичної активності вимагає впровадження новітніх технологій, що здатні забезпечити високу точність та ефективність у зборі та аналізі даних. 
Метою проєкту є розробка програмної системи для аналізу та моніторингу відвідувачів басейну, яка надає рекомендації на основі вимірів тіла. 
Розробка такої системи сприятиме підвищенню ефективності тренувань відвідувачів, покращенню їх мотивації та досягненню кращих результатів у підтримці фізичної форми. Впровадження технологій для персоналізованого підходу до тренувань відкриває нові можливості для розвитку спортивних комплексів та покращення якості надання послуг. 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Прямих конкурентів система немає (серед поширених та відомих компаній). Басейни можуть мати окремо якісь прилади для виміру одного або декількох показників (вага, тиск тощо), але це не є централізованим. Непрямими конкурентами можна назвати програми, які дозволяють вводити дані (наприклад, мобільний застосунок «Jefit»), але це потрібно тільки для ведення «щоденнику». Ці дані не можуть бути перевірені, бо їх вводить користувач, а не напряму отримуються з датчиків. Також користувачами не отримується ніяких рекомендацій щодо вдосконалення свого стану. І немає абсолютно ніякого духу змагань, котрий би заохочував людей до тренувань.
Тож, можемо виділити такі переваги системи:
	проєкт не має прямих конкурентів серед поширених та відомих компаній;
	отримані дані будуть використані для генерування рекомендацій;
	відображення місця у рейтингу конкретного басейну за даними.


1.1.2 Бізнес-цілі та критерії успіху


	БЦ-1: Залучення нових клієнтів: Заохотити не менш ніж 30% власників басейнів у п’яти найбільших містах України до використовування системи.
	БЦ-2: Пришвидшити аналіз: Швидкість повного аналізу повинна бути на 70% швидше, ніж звичайний огляд. 
	БЦ-3: Збільшення прибутку: Збільшити прибуток за рахунок надання якісніших за конкурентів послуг.
	КУ-1: Підвищення доходу: Підвищити  дохід програмного додатку на 30% від першого року після запуску.
	КУ-2: Залучення партнерів: Підписати угоду з компаніями-постачальниками датчиків для виміру у перші півроку після запуску.
	КУ-3: Підвищення кількості клієнтів: Підвищення кількості клієнтів на 60% у перші два роки після запуску.


1.1.3 Потреби клієнтів або ринку


У системи є два основні види користувачів: бізнес та його клієнти.
Потреби бізнесу:
	швидкість та простота налаштування системи;
	швидкість окупності вкладень у придбання системи;
	задоволеність послугами у клієнтів.

Потреби клієнтів:
	простота використання та зручний інтерфейс;
	точність та швидкість виміру.


1.1.4 Бізнес-ризики


Ризики:
	деякі басейни мають свою, «локальну» систему аналізу;
	велика вартість усієї системи для придбання;
	невдалий запуск системи.
Можливі дії:
	заохочувати до використання нашої системи;
	продавання системи у «оплату частинами»;
	проведення глобального запуску.


1.2 Концепція рішення
1.2.1 Окреслення концепції


Основною ідеєю проєкту є надання інформації про дані людини (вага, частота сердечних скорочень, процент жиру, тиск тощо), що відвідує басейн, рахування деяких значень (ІМТ, рівень стресу тощо) та згідно них давати рекомендації.
Продукт надасть тренуючимся можливість завжди стежити за своїми показниками для розрахунку ефективності своїх тренувань.
Основні переваги проєкту полягають у зменшенні часу на власний аналіз своїх показників або похід до лікаря.


1.2.2 Головна функціональність


MF-1: Зручний доступ: Користувачі можуть бачити свої дані з використанням мобільного додатку або веб-інтерфейсу.
MF-2: Багатомовний інтерфейс: Користувачі можуть користуватися додатком англійською й українською мовами.
	MF-3: Перегляд історії власних показників: Користувачі можуть дивитись свій прогрес у порівнянні з минулим часом.
MF-4: Отримання рекомендацій: На основі останніх показників генеруються рекомендації.
MF-5: Відображення міста в рейтингу: За усіма показниками усіх відвідувачів басейну буде сформований анонімний рейтинг, де користувач зможе побачити лише своє місце.
MF-6: Нагадування про тренування: За виставленним користувачем часом будуть приходити сповіщення про тренування.


1.2.3 Припущення та залежності


П-1: Користувачі мають комп’ютер та/або смартфон.
П-2: Присутнє інтернет-з’єднання під час користування сайтом або мобільним додатком.
П-3: У басейні буде необхідне місце для встановлення обладнання.
З-1: Встановлення системи має сенс лише у басейнах.
З-2: Компанія-постачальник датчиків повинна співпрацювати.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Серверна (back-end) частина повинна включати:
	реєстрацію та авторизацію користувачів: реалізація системи користувачів та механізмів входу з підтримкою ролей та прав доступу;
	рейтингова система: видача номеру у рейтингу користувача у басейні;
	сповіщення користувачів: відправлення сповіщень користувачам про необхідність тренування;
	захист даних: захист особистих даних користувачів;
	генерування рекомендацій: видача рекомендацій згідно отриманих даних;
	адміністрування системи: управління користувачами системи, управління  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами.
IoT частина повинна включати:
	зчитування даних датчиками, їх опрацювання та відправлення на серверну частину.
Front-end частина повинна включати:
	реєстрація та вхід користувачів: сторінки авторизації та реєстрації;
	панель моніторингу даних: переглядання даних, зчитаних з датчиків;
	рекомендації: отримання рекомендацій, заснованих на даних;
	адмін-панель: панель, що дозволяє управляти користувачами системи, управляти  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами;
	локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, порядку сортування текстових значень.
Мобільна частина повинна включати:
	реєстрація та вхід користувачів: сторінки авторизації та реєстрації;
	панель моніторингу даних: переглядання даних, зчитаних з датчиків;
	рекомендації: отримання рекомендацій, заснованих на даних;
	адмін-панель: панель, що дозволяє управляти користувачами системи, управляти  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами;
	отримання сповіщень: отримання сповіщень про необхідність тренування;
локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, порядку сортування текстових значень.


1.3.2 Рамки наступних випусків


У веб-застосунку користувачі будуть мати можливість:
	переглядати історію вимірів.
До функціоналу IoT можуть додатись більше датчиків для аналізу.
У мобільному застосунку користувачі будуть мати можливість переглядати історію вимірів.


1.3.3 Обмеження та винятки


	залежність від датчиків: функціональність системи залежна від справності датчиків;
	підключення до мережі інтернет: для отримання даних з датчиків потрібне підключення до інтернету;
	недостача місця: відсутність достатньої площі для розміщення.
1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Профілі зацікавлених сторін проекту наведені в таблиці 1.1.

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Бізнес	Можливість легкого та швидкого впровадження системи	Зацікавленість	Задовільненя потреб клієнтів	Доступ до інтернету
Звичайні користувачі	Легкість користування системою, можливість отримувати усю необхідну інформацію про доставку	Байдужість з переходом у ненависть або зацікавленість, в залежності від досвіду користування	Зручність, простота та необхідність у користуванні системою	Доступ до інтернету та фізична наявність у басейні
Розробник проєкту	Можливість заробити та отримання досвіду	Зацікавленість в успіху проєкту та задоволенні цільової аудиторії	Заробіток, репутація	Грошові обмеження
Партнери	Отримання прибутку	Зацікавленість у продовженні співпраці та у довгому «житті» проєкту	Прибуток	Грошові обмеження



1.4.2 Пріоритети проєкту


Пріоритети проєкту наведені в таблиці 1.2.

Таблиця 1.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Продукт має бути випущеним д о 31.05.2024		Можливе відхилення на 1-2 місяці
Функціональність			Весь критичний функціонал має працювати у версії 1.0
Якість			Система повинна проходити усі тести у версії 1.0
Персонал		Два розробники та адміністратор	
Ціна		20000 ₴	± 5%
	

1.4.3 Робоче середовище


Системою зможуть користуватися люди з будь-якої країни. 
Користувачі повинні мати безперервний доступ до системи. Це буде досягнуто завдяки хмарним сервісам Microsoft Azure.
Також важливо розширити доступність додатку завдяки локалізації (українська та англійська мови) та інтернаціоналізації (міри ваги, довжини тощо). 
Оскільки застосунок працюватиме в різних країнах, важливо врахувати різницю в часових поясах та представленні часу.
Дані будуть зберігатися в базі даних PostgreSQL. Доступ до даних здійснюватиметься за допомогою фреймворку Entity Framework Core.
Для розробки серверної частини буде використано ASP.NET Core Web API та мова програмування C#. Середовищем розробки буде JetBrains Rider.
Захист даних користувачів повинен бути забезпечений згідно GDPR.
Для розробки IoT частини буде використовуватися Arduino. Середовищем розробки буде Arduino IDE, що використовує мову програмування C++. Також до Arduino будуть під’єднані багато датчиків для виміру даних тіла (вага, процент жиру, тиск тощо).
Для розробки веб-застосунку буде використано фреймворк React.js. Середовищем розробки буде JetBrains WebStorm.
Для розробки мобільної частини буде використано технології MAUI (мова програмування C#). Середовищем розробки буде JetBrains Rider.
 
2 ПОСТАНОВКА ЗАДАЧІ


За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для аналізу та моніторингу відвідувачів басейну. База даних повинна включати інформацію про: відвідувачів, абонементи, відвідування, тренерів, розклад занять, зони басейну. Для клієнта має бути реалізований такий функціонал: 
–	реєстрація та вхід в систему; 
–	перегляд доступних абонементів та їх придбання; 
–	здача вимірів
–	перегляд власних рекомендацій; 
–	можливість запису та виходу зі басейну;
–	можливість редагування своїх даних;
Для адміністратора системи має бути реалізований такий функціонал: 
–	реєстрація та вхід в систему; 
–	керування користувачами системи; 
–	перегляд, додавання, редагування, видалення інформації про відвідувачів; 
–	керування абонементами та їхніми умовами; 
–	експорт та імпорт даних системи. 
Також програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати: підтримку різних кодових таблиць символів, обчислення та формат дати та часу, локальний та універсальний час, метричні одиниці вимірювання, англійську та американську систему мір, порядок сортування текстових значень, різні напрями введення тексту тощо. 
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


На підставі аналізу предметної області, було визначено основні сутності та встановлено зв’язки між ними. Їх було представлено у вигляді ER-діаграми (див. рис. 3.1).

 
Рисунок 3.1 – ER-діаграма бази даних

У базі даних наявні наступні зв’язки між сутностями:
	тип члену басейну та вимірів мають зв’язок один до багатьох, бо член басейну може мати багато вимірів;
	тип члену басейну та користувача мають зв’язок один до одного, бо до одного користувача може бути «прив’язаний» лише один член басейну;
	тип члену басейну та заяви на вступ до басейну мають зв’язок один до багатьох, бо один член басейну може подати багато заявок на вступ;
	тип басейну і члена басейну мають зв’язок один до багатьох, бо у одного басейну може бути багато членів;
	тип басейну та заяви на вступ до басейну мають зв’язок один до багатьох, бо один басейн може мати багато заявок на вступ;


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Для забезпечення нормалізації бази даних, варто усунити зв’язок «багато-до-багатьох» між сутностями Член басейну та Басейн. Для цього створимо проміжну сутність «Запити до басейну».
Отже, у логічній моделі бази даних будуть представлені такі сутності:
	члени басейну (Users);
	виміри (Measurements);
	користувачі (Users);
	басейни (Pools);
	рекомендації (Recommendations);
	запити до басейну (PoolEnrollmentRequests);
Створимо таблицю користувачів (Users). Вона буде містити у собі такі атрибути: Id (первинний ключ), UserName, NormalizedUserName, Email, NormalizedEmail, PasswordHash. 
Перевіримо таблицю Users на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю членів басейну (Members). Вона буде містити у собі такі атрибути: Id, FirstName, LastName, Sex, DateOfBirth.
Перевіримо таблицю Members на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю вимірів (Measurements). Вона буде містити у собі такі атрибути: Id, DateAndTime, Height, Weight, FatPercentage, MusclePercentage, UpperPressure, LowerPressure, BodyMassIndex, LevelOfStress.
Перевіримо таблицю Measurements на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю басейнів (Pools). Вона буде містити у собі такі атрибути: Id, Name, Address, City, Country, Description.
Перевіримо таблицю Pools на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Створимо таблицю запитів (PoolEnrollmentRequests). Вона буде містити у собі такі атрибути: Id, Member, Pool, DateAndTime.
Перевіримо таблицю PoolEnrollmentRequests на відповідність нормалізації:
	усі атрибути атомарні: містять лише одне значення, а не множину;
	відсутність повторюваності даних;
	усі неключові атрибути залежать від первинного ключа.
Отже, таблиця задовольняє першій, другій і третій нормальній формі.
Оскільки всі таблиці бази даних знаходяться в третій нормальній формі, то можна зробити висновок, що отримана база даних знаходиться в третій нормальній формі.
 
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Основними користувачами програмної системи для моніторингу та аналізу відвідувачів басейну «Lieb ist Pool» є два типи акторів: клієнт і адміністратор. 
Основні потреби клієнта включають можливість перегляду доступних басейнів та їхніх послуг, перегляд фізичних показників, отримання персоналізованих рекомендацій щодо тренувань, редагування власної інформації.
Основні потреби адміністратора включають керування користувачами системи (реєстрація, редагування, видалення), управління списком доступних басейнів, створення, редагування та видалення фізичних параметрів і рекомендацій для відвідувачів, забезпечення безпеки даних користувачів та системи в цілому, створення резервних копій даних та їх імпорт у систему, моніторинг і аналіз членів басейну. 
Взаємодія користувачів із серверною частиною системи зображена на діаграмі прецедентів (див. рис. 4.1).

 
Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи
Для написання серверної частини системи було обрано мову програмування C# з використанням технології ASP.NET Core Web API, яка забезпечує швидку розробку, високу продуктивність та надійність. 
У якості бази даних використано PostgreSQL, до якої з серверного застосунка здійснюється доступ за допомогою технології Entity Framework Core, що надає зручний інтерфейс для взаємодії з базами даних у вигляді об’єктів сутностей. 
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).

 
Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи

Для демонстрації та тестування API використовується OpenApi (Swagger), що дозволяє зручно тестувати та документувати API, покращуючи якість та зручність розробки. 
Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі. 
Для автоматизації процесу мапування між об’єктами використано бібліотеку AutoMapper. Це дозволяє зменшити кількість одноманітного коду при роботі з об'єктами даних та спрощує розробку серверної частини. 
Для реалізації автентифікації та авторизації використано бібліотеку .NET Identity, що дозволяє що забезпечує гнучкий та потужний механізм для управління користувачами та їхнім доступом до різних частин системи. 
Для маршрутизації запитів використанні API контролери, що є вбудованими засобами розробки на ASP.NET Core. Вони дозволяють розділити програму на логічні компоненти, кожен з яких відповідає за обробку конкретного виду запитів або дій користувача. Це спрощує керування кодом та його розширення. 
Розроблений серверний застосунок побудований за принципами Clean Architecture та складається з декількох шарів: Presentation рівень, Application рівень, Domain рівень та Infrastructure рівень. Кожний вищий шар залежить від нижчого. 
У якості способу організації коду було обрано CQRS (Command Query Responsibility Segregation), який розділяє команди, які змінюють стан системи, від запитів, які повертають дані про стан системи. Цей спосіб організації коду сприяє чіткому структуруванню коду та забезпечує легку розширюваність функціональності системи [4]. 
Також для організації архітектури застосунка було використано шаблон Mediator. Він дозволяє об'єктам взаємодіяти один з одним, не знаючи безпосередньо один про одного, що сприяє зменшенню залежностей між компонентами системи, тим самим збільшуючи стійкість та масштабованість системи.
Архітектура серверного застосунка представлена на діаграмі пакетів (див. рис. 4.3). 

 
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи

Приклади частин коду серверного застосунка представлено у додатку А.
Таким чином, було визначено технології й архітектуру серверної частини програмної системи.


4.2 Архітектура IoT частини


Користувачем IoT частини розробленої системи є клієнт. Основними потребами клієнта є здача вимірів свого тіла завдяки різноманітним датчикам та отримання рекомендацій на екрані IoT пристрою або на сайті. Взаємодію кожної ролі користувачів з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4). 

 
Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи

Для демонстрації функціональних можливостей IoT частини системи було вирішено реалізувати програмний код мовою програмування C#, що максимально відповідає обмеженням апаратних ресурсів IoT пристроїв завдяки можливості компіляції у режимі Native AoT. Для виведення інформації використовую консольний інтерфейс (CLI). Надсилання даних реалізовано за допомогою бібліотеки System.Net.Http, а самі дані передаються у форматі JSON. 
Програма призначена для тривалого доступу на сервері, де існує таблиця з ідентифікаторами, які можна присвоїти IoT пристрою. Це надає можливість записувати показники датчика протягом тривалого періоду. 
Код програми написано з мінімальною кількістю рядків для оптимізації під пристрої з обмеженою потужністю. Крім того, програма легко портується на реальні IoT пристрої.

Для більш детальної візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.5).


 
Рисунок 4.5 – Діаграма пакетів IoT частини програмної системи

Зпершу IOT-пристрій під'єднується до Wi-Fi, далі авторизовує користувача за допомогою NFC-браслету, дали зчитує необхідні виміри і надсилає дані на сервер. На основі описаної взаємодії пристрою с користувачем було побудовано діаграму взаємодії (див. рис. 4.6).

 
Рисунок 4.6 – Діаграма взаємодії IoT частини програмної системи

На основі описаної діяльності пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7). 

 
Рисунок 4.7 – Діаграма діяльності IoT частини програмної системи

Таким чином, за допомогою діаграм пакетів, станів та діяльності було визначено основні технології та архітектуру системи. 
Приклади коду IoT частини системи представлено у додатку Б.1. 

4.3 Архітектура клієнтської частини


Користувачами клієнтської частини розробленої системи є 2 типи акторів: адміністратор та член басейну.
Основними потребами клієнта є: можливість подавати заяву у басейн, дивитись свій профіль, бачити свої здані виміри, отримувати рекомендації згідно вимірів
Основними потребами адміністратора є: адміністрування басейну, адміністрування користувачів, експортування/імпортування даних.
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
Взаємодію кожної ролі користувачів з клієнтською частиною системи представлено на діаграмі прецедентів (див. рис. 4.8).

 
Рисунок 4.8 – Діаграма прецедентів клієнтської частини програмної системи
Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням технології React, що забезпечує високу швидкодію розробки і зручність у використанні за рахунок статичної типізації та компонентного підходу.
Для реалізації елементів інтерфейсу було використано бібліотеки Material UI, які надають готові та стилізовані компоненти інтерфейсу для швидкої і зручної розробки візуально привабливого вебзастосунку.
Для реалізації локалізації інтерфейсу було використано бібліотеку i18next, що дозволяє легко і ефективно впроваджувати багатомовний інтерфейс та забезпечує зручний механізм перекладу текстових рядків.
Для реалізації навігації по сайту використано бібліотеку react-router-dom, яка надає зручні та потужні інструменти для створення реактивної навігації та управління маршрутами вебзастосунку.
Для виконання асинхронних запитів на сервер використано бібліотеку axios, яка забезпечує зручний та потужний інтерфейс для взаємодії з HTTP-запитами та дозволяє легко обробляти відповіді від сервера.
Для розгортання серверу використано інструмент побудови Vite, який надає швидкий та ефективний спосіб розгортання вебзастосунку, дозволяючи легко налаштовувати середовище розробки та підтримує автоматичне оновлення в реальному часі. 
Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.9).

 
Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи

Розроблено клієнтську частину за допомогою Feature-Sliced архітектури. Вона визначає побудову проєкта за допомогою шарів. 
Шари включають зрізи, які в свою чергу включають сегменти. Шари – це каталоги верхнього рівня застосунку. У проєкті визначено 7 шарів: app, pages, components, features, interfaces, context та hooks. Шар app визначає основну конфігурацію застосунку. Шар pages містить сторінки сайту. Шар components містить різні компоненти інтерфейсу, які можна перевикористовувати. Шар features відповідає за функціонал застосунку. Він визначає дії, доступні користувачу в системі. Шар interfaces визначає інтерфейси моделей, які використовуються для обміну даними з сервером та їхнього представлення на сторінках. Шар context визначає об’єкти контексту, які дозволяють передачу даних іншим компонентам, які відповідають контексту. Шар hooks відповідає за об’єкти хуків, які дозволяють компонентам отримувати доступ до станів системи. 
Для більш детальної візуалізації архітектури системи було розроблено діаграму компонентів (див. рис. 4.10).

 
Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи

Взаємодія користувача з клієнтською частиною починається з введення даних профілю (при реєстрації або входу). Після авторизації, згідно ролі користувача, взаємодія розділяється на клієнтську та адміністраторську.
Клієнт має можливість записатись у басейн. Для цього він у своєму профілі обирає доступний басейн зі списку та очікує схвалення або відхилення заяви від адміністратору басейну. Також клієнт може отримувати рекомендації за вимірами, які він здав у басейні.
Адміністратор має можливість керування басейнами, набирати членів до басейну та експортувати дані.
Для більш детальної візуалізації взаємодії користувачів з клієнтської частиною системи було розроблено діаграму взаємодії (див. рис. 4.11). 

 
Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи

Приклади коду клієнтської частини системи представлено у додатку В.
Таким чином, було визначено технології й архітектуру клієнтської частини програмної системи. 
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Для виклику програми необхідно завантажити архів, у якому вона розповсюджується, та розархівувати її. Оскільки у програмному продукті використовується з’єднання із СУБД PostgreSQL, необхідно встановити її останню версію з офіційного сайту виробника. 
Щоб забезпечити з’єднання застосунку з базою даних, потрібно відкрити файл appsettings.json за шляхом «apz-pzpi-21-10-hotvianskyi-kyrylo\Task2\apz-pzpi-21-10-hotvianskyi-kyrylo-task2\Api» за допомогою будь-якого текстового редактора та змінити вміст рядку, виділеного червоним на рисунку 5.1, у відповідності до інформації, яка є необхідною для входу до бази даних, встановленої на комп'ютері.

 
Рисунок 5.1 – Рядок підключення у файлі appsettings.json

Далі необхідно запустити серверну частину системи. Для цього можна використати засоби середовища розробки Rider, яку необхідно завантажити з офіційного сайту виробника. Відкривши Backend.sln у папці «apz-pzpi-21-10-hotvianskyi-kyrylo-task2», треба скомпілювати та запустити програму.
Далі необхідно запустити клієнтську частину системи. Для цього можна використати засоби середовища розробки WebStorm, яку необхідно завантажити з офіційного сайту виробника. Відкривши проект у папці «apz-pzpi-21-10-hotvianskyi-kyrylo-task4», треба у термінали прописати команди «npm install» та «npm run dev».

Для запуску IoT частини необхідно відкрити папку «apz-pzpi-21-10-hotvianskyi-kyrylo-task3», далі відкрити файл «IoT.sln» за допомогою Rider, встановленого з офіційного сайту, скомпілювати та запустити проект.


5.2 Призначення і логічна структура


Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
	авторизація та реєстрація;
	користувачі;
	басейни;
	виміри;
	дані системи;
	сертифікати системи;
	користувачі системи;
	рекомендації.
Модуль «Авторизація та реєстрація» містить у собі функції для входу в систему та створення нового облікового запису. Реєстрація дозволяє клієнту створити свій запис у базі даних та надалі отримувати до нього доступ за допомогою свого логіну та пароля. За замовчуванням, для доступу до акаунта адміністратора необхідно авторизуватися з поштою admin@localhost.com і паролем P@ssword1.
Модуль «Користувачі» містить у собі функції для перегляду, додавання, редагування та скасування користувачів. 
Модуль «Виміри» містить у собі необхідний функціонал для здавання вимірів на основі IoT системи.
Модуль «Басейни» містить у собі функції для перегляду, додавання, редагування та скасування користувачів.
Модуль «Дані системи» є адміністраторським, і містить у собі функції для експорту та імпорту даних системи.
Модуль «Сертифікати системи» є адміністраторським, і містить у собі функції для експорту та імпорту сертифікатів системи.
Модуль «Користувачі системи» є адміністраторським, і містить у собі функції для керування користувачами системи.
Модуль «Рекомендації» містить у собі необхідну інформацію для генерації точних рекомендацій на основі даних вимірів 
	

5.3 Опис програмної реалізації


При відкритті клієнтського застосунка можна побачити головну сторінку (див. рис. 5.2). 
З неї можна перейти до сторінки авторизації, а також налаштувати локалізацію сайту, натиснувши на символ локалізації у правому верхньому куті сайту. На вибір доступні англійська та українська мови. На сайті також присутня інтернаціоналізація, яка залежить від регіону браузера.


 
Рисунок 5.2 – Головна сторінка сайту

На сторінці авторизації (див. рис. 5.3) необхідно обрати: створити обліковий запис клієнта або увійти в систему.

 
Рисунок 5.3 – Сторінка авторизації

При створенні нового облікового запису треба увести електронну пошту та пароль нового користувача (див. рис. 5.4).

 
Рисунок 5.4 – Сторінка реєстрації

При входу в обліковий запис треба увести електронну пошту та пароль існуючого користувача. Також можна перейти до сторінки реєстрації (див. рис. 5.5).

 
Рисунок 5.5 – Сторінка входу в систему

Після входу користувач отримує доступ до сторінок «Профіль» та «Мої виміри». Розглянемо сторінку профілю (див. рис 5.6).

 
Рисунок 5.6 – Сторінка профілю

	Користувач може редагувати своє ім’я та прізвище та подавати заяви до басейнів. Після подачі заяви бачимо інформацію (див. рис. 5.7).

 
Рисунок 5.7 – Подача заяви у басейн

	Розглянемо сторінку вимірів (див. рис. 5.8)

 
Рисунок 5.8 – Сторінка вимірів

	Користувач може отримати рекомендації на основі кожного виміру (див. рис. 5.9)

 
Рисунок 5.9 – Рекомендації на основі другого виміру

	Далі розглянемо сторінку адміністратора. Після входу в систему з обліковим записом адміністратора, у верхній панелі можна побачити вкладинку «Запити у басейн» та «Експортування даних» (див. рис. 5.10).

 
Рисунок 5.10 – Можливості адміністратора

	При переході до запитів до басейнів можемо побачити запити до басейнів (див. рис. 5.11). Адміністратор може схвалити запит у свій басейн чи відхилити

 
Рисунок 5.11 – Запити до басейнів

На сторінці експортування даних адміністратор має можливість завантажити дані у форматі екселю (див. рис. 5.12)

 
Рисунок 5.12 – Таблиці користувачів та поїздок

	Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою. 
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему на основі предметної області «Мережа таксі автономного керування».
У процесі роботи було проаналізовано предметну область, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмними засобами ASP.NET Core, Arduino та React.js.
Розроблена програмна система дозволяє користувачам зручно організовувати та коректувати свій тренувальний план та спосіб життя завдяки отриманим рекомендаціям та відслідковуванню прогресу.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 25.05.2024).
2.	ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 25.05.2024).
3.	React Reference Overview – React. URL: https://react.dev/reference/react (дата звернення: 25.05.2024).
4.	Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
5.	Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008. 
ДОДАТОК А
Програмний код серверної частини
А.1 Код основного файлу для роботи сервера Program.cs:


1 using Api.Middleware;
2 using Application;
3 using Identity;
4 using Microsoft.IdentityModel.Logging;
5 using Microsoft.OpenApi.Models;
6 using Persistence;
7 
8 var builder = WebApplication.CreateBuilder(args);
9 
10 // Add services to the container.
11 
12 builder.Services.AddApplicationServices();
13 builder.Services.AddPersistenceServices(builder.Configuration);
14 builder.Services.AddIdentityServices(builder.Configuration);
15 
16 builder.Services.AddControllers();
17 
18 builder.Services.AddCors(options =>
19 {
20     options.AddPolicy("all", builder =>
21     {
22         builder.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod();
23     });
24 });
25 // Add HttpContext to interact with current request
26 builder.Services.AddHttpContextAccessor();
27 // Add Swagger to the project
28 builder.Services.AddEndpointsApiExplorer();
29 builder.Services.AddSwaggerGen(options =>
30 {
31     // Add JWT Authentication description to Swagger
32     options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme()
33     {
34         Description = "Jwt Auth header using the bearer scheme. Enter 'Bearer' [space] and then your token in the text input below.",
35         Name = "Authorization",
36         In = ParameterLocation.Header,
37         Scheme = "Bearer"
38     });
39     // Add JWT Authentication requirement to Swagger
40     options.AddSecurityRequirement(new OpenApiSecurityRequirement()
41     {
42         {
43             new OpenApiSecurityScheme()
44             {
45                 Reference = new OpenApiReference()
46                 {
47                     Type = ReferenceType.SecurityScheme,
48                     Id = "Bearer"
49                 },
50                 Scheme = "oauth2",
51                 Name = "Bearer",
52                 In = ParameterLocation.Header
53             },
54             new List<string>()
55         }
56     });
57 });
58 
59 var app = builder.Build();
60 // Use global exception handler
61 app.UseMiddleware<ExceptionMiddleware>();
62 
63 // Configure the HTTP request pipeline.
64 if (app.Environment.IsDevelopment())
65 {
66     app.UseSwagger();
67     app.UseSwaggerUI();
68     // Show more detailed errors in development
69     IdentityModelEventSource.ShowPII = true; 
70 }
71 
72 app.UseHttpsRedirection();
73 // Use "all" CORS policy, specified above
74 app.UseCors("all");
75 // Use authentication and authorization
76 app.UseAuthentication();
77 app.UseAuthorization();
78 
79 app.MapControllers();
80 
81 app.Run();




А.2 Код обробника виключень:


1 using System.Net;
2 using Api.Models;
3 using Application.Exceptions;
4 using Newtonsoft.Json;
5 
6 namespace Api.Middleware;
7 
8 public class ExceptionMiddleware
9 {
10     private readonly RequestDelegate _next;
11     private readonly ILogger<ExceptionMiddleware> _logger;
12 
13     public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger)
14     {
15         _next = next;
16         _logger = logger;
17     }
18 
19     public async Task InvokeAsync(HttpContext httpContext)
20     {
21         try
22         {
23             // If there is no exception, then the request is passed to the next middleware
24             await _next(httpContext);
25         }
26         catch (Exception ex)
27         {
28             // If there is an exception, then the request is handled by this middleware
29             await HandleExceptionAsync(httpContext, ex);
30         }
31     }
32 
33     private async Task HandleExceptionAsync(HttpContext httpContext, Exception ex)
34     {
35         HttpStatusCode statusCode;
36         CustomProblemDetails problem;
37 
38         switch (ex)
39         {
40             /*
41              * If the exception is of type BadRequestException, then the status code is 400
42              * and the validation errors are returned in the response body
43             */
44             case BadRequestException badRequestException:
45                 statusCode = HttpStatusCode.BadRequest;
46                 problem = new CustomProblemDetails
47                 {
48                     Title = badRequestException.Message,
49                     Status = (int)statusCode,
50                     Type = nameof(BadRequestException),
51                     Errors = badRequestException.ValidationErrors
52                 };
53                 break;
54             /*
55              * If the exception is of type NotFoundException, then the status code is 404
56              * and the exception message is returned in the response body
57             */
58             case NotFoundException notFound:
59                 statusCode = HttpStatusCode.NotFound;
60                 problem = new CustomProblemDetails
61                 {
62                     Title = notFound.Message,
63                     Status = (int)statusCode,
64                     Type = nameof(NotFoundException),
65                 };
66                 break;
67             /*
68              * If the exception is not specific, then the status code is 500
69              * and the stack trace and exception is logged 
70             */
71             default:
72                 statusCode = HttpStatusCode.InternalServerError;
73                 problem = new CustomProblemDetails
74                 {
75                     Title = "An internal server error occurred",
76                     Status = (int)statusCode,
77                     Type = nameof(HttpStatusCode.InternalServerError),
78                 };
79                 
80                 var logMessage = $"Message: {ex.Message}\nStackTrace: {ex.StackTrace}";
81                 _logger.LogError(logMessage);
82                 break;
83         }
84 
85         httpContext.Response.StatusCode = (int)statusCode;
86         await httpContext.Response.WriteAsJsonAsync(problem);
87     }
88 }

А.3 Код класу, відповідного за БД:


1 using Domain;
2 using Microsoft.EntityFrameworkCore;
3 using Persistence.Repositories;
4 
5 namespace Persistence.DatabaseContext;
6 
7 public class DataContext : DbContext
8 {
9     public DataContext(DbContextOptions<DataContext> options) : base(options)
10     {
11         
12     }
13     
14     protected override void OnModelCreating(ModelBuilder builder)
15     {
16         base.OnModelCreating(builder);
17         builder.ApplyConfigurationsFromAssembly(typeof(DataContext).Assembly);
18     }
19     
20     public DbSet<Member> Members { get; set; } = null!;
21     public DbSet<Pool> Pools { get; set; } = null!;
22     public DbSet<Measurement> Measurements { get; set; } = null!;
23     public DbSet<PoolEnrollmentRequest> PoolEnrollmentRequests { get; set; } = null!;
24     public DbSet<Recommendation> Recommendations { get; set; } = null!;
25 }
 
ДОДАТОК Б
Програмний код IoT пристрою
Б.1 Код файлу для відправлення запитів на серверну частину


1 public class BackendClient
2 {
3     private readonly HttpClient _client = new HttpClient()
4     {
5         BaseAddress = new Uri("https://localhost:44328/api/v1/"),
6     };
7     /// <summary>
8     /// Login in and get token
9     /// </summary>
10     /// <param name="loginCommand">Email and password of the user (with "Member" role)</param>
11     /// <returns>If all is good, then <see cref="LoginResponse"/> is returned. <see cref="BadRequestResponse"/> is returned in case of validation error. </returns>
12     /// <exception cref="Exception">Throws if server exception occured</exception>
13     public async Task<BaseResponse> Login(LoginCommand loginCommand)
14     {
15         var loginResult = await _client.PostAsJsonAsync("auth/login", loginCommand);
16         
17         switch (loginResult.StatusCode)
18         {
19             case HttpStatusCode.OK:
20                 return (await loginResult.Content.ReadFromJsonAsync<LoginResponse>())!;
21             case HttpStatusCode.BadRequest:
22                 return (await loginResult.Content.ReadFromJsonAsync<BadRequestResponse>())!;
23             default:
24                 throw new Exception("Login failed");
25         }
26     }
27 
28     /// <summary>
29     /// Create measurement for user with specified token
30     /// </summary>
31     /// <param name="createMeasurementCommand">Data for creating a measurement</param>
32     /// <param name="token">Token of the user (with "Member" role)</param>
33     /// <returns>If all is good, then <see cref="BaseResponse"/> is returned. <see cref="BadRequestResponse"/> is returned in case of validation error. </returns>
34     /// <exception cref="Exception">Throws if server exception occured</exception>
35     public async Task<BaseResponse> CreateMeasurement(CreateMeasurementCommand createMeasurementCommand, string token)
36     {
37         _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
38         
39         var createMeasurementResult = await _client.PostAsJsonAsync("measurements", createMeasurementCommand);
40         switch (createMeasurementResult.StatusCode)
41         {
42             case HttpStatusCode.Created:
43                 return new BaseResponse();
44             case HttpStatusCode.BadRequest:
45                 return (await createMeasurementResult.Content.ReadFromJsonAsync<BadRequestResponse>())!;
46             default:
47                 throw new Exception("Create measurement failed");
48         }
49     }
50 }
 
ДОДАТОК В
Програмний код клієнтської частини
В.1 Код для відправлення запитів


1 import axios from "axios";
2 import apiClient from "../config/apiClient";
3 import {MemberDto, UpdateMemberCommand} from "../interfaces/member.ts";
4 
5 const updateMember = async (
6     token : string,
7     updateMemberCommand : UpdateMemberCommand
8 ) : Promise<void> => {
9     try {
10         const headers = {
11             'Authorization': 'Bearer ' + token
12         };
13         await apiClient.put(
14             'members/updateInfo',
15             updateMemberCommand,
16             { headers }
17         );
18         return;
19     } catch (error) {
20         if (axios.isAxiosError(error)) {
21             throw new Error(error.response?.data.message);
22         } else {
23             throw new Error("Unknown error occurred.");
24         }
25     }
26 }
27 
28 const getMemberByUser = async (
29     token : string
30 ) : Promise<MemberDto> => {
31     try {
32         const headers = {
33             'Authorization': 'Bearer ' + token
34         };
35         const response = await apiClient.get<MemberDto>(
36             'members/getByUser',
37             { headers }
38         );
39         return response.data;
40     } catch (error) {
41         if (axios.isAxiosError(error)) {
42             throw new Error(error.response?.data.message);
43         } else {
44             throw new Error("Unknown error occurred.");
45         }
46     }
47 }
48 
49 const enrollMemberToPool = async (
50     token : string,
51     memberId : number,
52     poolId : number
53 ) : Promise<void> => {
54     try {
55         const headers = {
56             'Authorization': 'Bearer ' + token
57         };
58         await apiClient.put(
59             'members/enrollToPool',
60             { memberId, poolId },
61             { headers }
62         );
63         return;
64     } catch (error) {
65         if (axios.isAxiosError(error)) {
66             throw new Error(error.response?.data.message);
67         } else {
68             throw new Error("Unknown error occurred.");
69         }
70     }
71 }
72 
73 export const membersService = {
74     updateMember,
75     getMemberByUser,
76     enrollMemberToPool
77 };


В.2 Код сторінки вимірів користувача


1 import {
2     Box,
3     Container,
4     IconButton,
5     Paper,
6     Table,
7     TableBody,
8     TableCell,
9     TableHead,
10     TableRow,
11     Typography
12 } from "@mui/material";
13 import {useTranslation} from "react-i18next";
14 import useAuth from "../hooks/useAuth.ts";
15 import InfoIcon from '@mui/icons-material/Info';
16 import {useEffect, useState} from "react";
17 import {measurementsService} from "../features/measurementsService.ts";
18 import {MeasurementDto} from "../interfaces/measurement.ts";
19 import {RecommendationDto} from "../interfaces/recommendation.ts";
20 
21 export default function Measurements() {
22     const { t } = useTranslation();
23     const { auth } = useAuth();
24     const [measurements, setMeasurements] = useState<MeasurementDto[]>();
25     const [recommendations, setRecommendations] = useState<RecommendationDto[]>()
26 
27     useEffect(() => {
28         const fetchMeasurements = async () => {
29             try {
30                 const response = await measurementsService.getAllMeasurementsByMember(auth.bearer!);
31                 setMeasurements(response);
32             } catch (error) {
33                 console.error('Error fetching pools:', error);
34             }
35         };
36         fetchMeasurements();
37     }, [auth.bearer]);
38 
39     const handleGetRecomendation = async (measurementId: number) => {
40         try {
41             const recommendations : RecommendationDto[] = await measurementsService.getRecommendationByIdForMember(auth.bearer!, measurementId);
42             setRecommendations(recommendations)
43         } catch (error) {
44             console.error('Error fetching pools:', error);
45         }
46     }
47 
48     return (
49         <Container>
50             <Typography variant="h5" gutterBottom align="center" mt={3} mb={2}>
51                 {t('measurements')}
52             </Typography>
53 
54             <Paper elevation={3} style={{ padding: '20px', paddingBottom: '20px' }}>
55                 {measurements?.length === 0 && (
56                     <>
57                         <Typography variant="h5" gutterBottom align="center" mt={3} mb={2}>
58                             {t('noMeasurements')}
59                         </Typography>
60                         <Typography variant="h6" gutterBottom align="center" mt={3} mb={2}>
61                             {t('makeOneMeasurement')}
62                         </Typography>
63                     </>)}
64                 <Table sx={{ mb: 2 }}>
65                     <TableHead>
66                         <TableRow>
67                             <TableCell>{t('date')}</TableCell>
68                             <TableCell>{t('height')}</TableCell>
69                             <TableCell>{t('weight')}</TableCell>
70                             <TableCell>{t('fatPercentage')}</TableCell>
71                             <TableCell>{t('musclePercentage')}</TableCell>
72                             <TableCell>{t('pressure')}</TableCell>
73                             <TableCell>{t('bmi')}</TableCell>
74                             <TableCell>{t('levelOfStress')}</TableCell>
75                             <TableCell></TableCell>
76                         </TableRow>
77                     </TableHead>
78                     <TableBody>
79                         {measurements?.map((measurement, index) => {
80                                 const date = new Date(measurement.dateAndTime);
81                                 const dataParseOptions: Intl.DateTimeFormatOptions = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric' };
82                                 return <TableRow key={index}>
83                                     <TableCell>{new Intl.DateTimeFormat('en-US', dataParseOptions).format(date)}</TableCell>
84                                     <TableCell>{measurement.height}</TableCell>
85                                     <TableCell>{measurement.weight}</TableCell>
86                                     <TableCell>{measurement.fatPercentage}</TableCell>
87                                     <TableCell>{measurement.musclePercentage}</TableCell>
88                                     <TableCell>{`${measurement.upperPressure}/${measurement.lowerPressure}`}</TableCell>
89                                     <TableCell>{measurement.bodyMassIndex}</TableCell>
90                                     <TableCell>{measurement.levelOfStress}</TableCell>
91                                     <TableCell>
92                                         <Box display="flex" flexDirection="row">
93                                             <IconButton
94                                                 color="primary"
95                                                 aria-label={t('addToCart')}
96                                                 onClick={() =>
97                                                     handleGetRecomendation(
98                                                         measurement.id
99                                                     )
100                                                 }
101                                             >
102                                                 <InfoIcon/>
103                                             </IconButton>
104                                         </Box>
105                                     </TableCell>
106                                 </TableRow>
107                             }
108                         )}
109                     </TableBody>
110                 </Table>
111 
112                 <Typography variant="h5" gutterBottom align="center" mt={3} mb={2}>
113                     {recommendations && recommendations.map((recommendation) => {
114                             return (
115                                 <Typography variant="h6" gutterBottom align="center" mt={3} mb={2}>
116                                     {t(recommendation.key)}
117                                 </Typography>
118                             )
119                         })
120                     }
121                 </Typography>
122             </Paper>
123         </Container>
124     )
125 }



